\section{Implementation}
\subsection{Information restructuring}

We've cleaned and refactored the code, events have been placed in their consecutive class.
The following elements have been moved to $Events.h$
\\
\texttt{network\_layer\_allowed\_to\_send}
\break
\texttt{network\_layer\_ready}
\break
\texttt{data\_for\_network\_layer}
\break

We've added the following two signals/events to the $Events.h$

\begin{lstlisting}
#define NL_SendingQueueOffer    0x00000020 //TL->NL: Offer NL a queue of elements for NL to forward. The offered concurrentFifoQueue is assumed locked.
#define TL_ReceivingQueueOffer  0x00000040 //NL->TL: Offer TL a queue of elements for it to receive. The offered concurrentFifoQueue is assumed locked.
\end{lstlisting}

furtheremore, we've removed some locks and unified them under a single lock



$TL_OfferElement$ is used by the NL to figure out where to process the segment

\begin{lstlisting}
typedef struct {
  networkAddress receiver;  //This contains ``fake'' ip address of the reciever
  payload seg;              //our payload is the msg
} TL_OfferElement;
\end{lstlisting}

our implmenetation of the transportlayer is as follows:

\begin{lstlisting}
\end{lstlisting}

the goal is to make the network layer and transport layer communicate with each other, this is done by TODO:


to achieve this/to make this possible a routing table has been implemented with the goal of routing hosts across the network.

TODO: put routing table implementation here

We've implemented a FIFO queue, the idea is to have two queue one for the reciving end and one for the sending end.
We've chosen to make the receivingQueue concurrent because it is shared between TL and the NL.
The concurrency is provided via a simple lock.

\begin{lstlisting}
ConcurrentFifoQueue receivingQueue = CFQ_Init(); //This is concurrent because it is used for communication with the transport layer. The queue is also used for consistence and expandability.
FifoQueue sendingQueue = InitializeFQ(); //Doesn't need to be concurrent because elements are given with signals.
\end{lstlisting}

\\




The NL routing table is implemented the following way.
Here we've defined a static variable, in the real world the $NL_ROUTING_TABLE_SIZE$ should be incremented and decremented dynamically.
\begin{lstlisting}
//Routing table. There can be more elements in this table than there are neighbours and multiple entries can point to the same neighbour.
#define NL_ROUTING_TABLE_SIZE 4
typedef struct {
  networkAddress addresses[NL_ROUTING_TABLE_SIZE];
  neighbourid    neighbourids[NL_ROUTING_TABLE_SIZE];
} NL_RoutingTable;
\end{lstlisting}

\break


The NL offer Element
\begin{lstlisting}
typedef struct {
  neighbourid otherHostNeighbourid;
  datagram dat;
} NL_OfferElement;
\end{lstlisting}

\break

\begin{lstlisting}
typedef struct {
  neighbourid neighbour;
  unsigned int bufferSlotsAvailable;
} NL_RequestFromLL;

\end{lstlisting}



Under the $send_frame(...)$ function we've updated our neighbour addressing to recieve an address instead of a static value.
\begin{lstlisting}
neighbours[recipient].no_nak = false;        /* one nak per frame, please */
\end{lstlisting}














we initialize our networklayer in the following manner.
Each host/station is assigned an address

\begin{lstlisting}
void initialize_networkLayer(int stationID) {
   switch(stationID) {
     case 1: //Host A
      thisNetworkAddress = 111;
       ROUTINGTABLEADD(0, 212, 0);
       ROUTINGTABLEADD(1, -1, -1);
       ROUTINGTABLEADD(2, -1, -1);
       ROUTINGTABLEADD(3, -1, -1);
       break;
     case 2: //Host B
       thisNetworkAddress = 212;
      ROUTINGTABLEADD(0, 111, 0);
       ROUTINGTABLEADD(1, -1, -1);
       ROUTINGTABLEADD(2, -1, -1);
       ROUTINGTABLEADD(3, -1, -1);
       break;
     case 3: //Router 1

      thisNetworkAddress = 313;
      ROUTINGTABLEADD(0, 111, 0);
      ROUTINGTABLEADD(1, 212, 1);
      ROUTINGTABLEADD(2, -1, -1);
      ROUTINGTABLEADD(3, -1, -1);
      break;
     case 4: //Router 2

       //break;
@@ -46,6 +50,22 @@ void initialize_networkLayer(int stationID) {
   }
 }
\end{lstlisting}



\hfill \break
