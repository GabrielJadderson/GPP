\section{Implementation}
\subsection{Information restructuring}

We've cleaned and refactored the code, events have been placed in their consecutive class.
The following elements have been moved to $Events.h$
\\
\texttt{network\_layer\_allowed\_to\_send}
\break
\texttt{network\_layer\_ready}
\break
\texttt{data\_for\_network\_layer}
\break

We've added the following two signals/events to the $Events.h$

\begin{lstlisting}
#define NL_SendingQueueOffer    0x00000020 //TL->NL: Offer NL a queue of elements for NL to forward. The offered concurrentFifoQueue is assumed locked.
#define TL_ReceivingQueueOffer  0x00000040 //NL->TL: Offer TL a queue of elements for it to receive. The offered concurrentFifoQueue is assumed locked.
\end{lstlisting}

furtheremore, we've removed some locks and unified them under a single lock



$TL_OfferElement$ is used by the TL to figure out where to process the segment

\begin{lstlisting}
typedef struct {
  networkAddress receiver;  //This contains ``fake'' ip address of the reciever
  payload seg;              //our payload is the msg
} TL_OfferElement;
\end{lstlisting}

Similarly $NL_OfferElement$ is used by in the communication between LL and NL.
\begin{lstlisting}
typedef struct {
  neighbourid otherHostNeighbourid;
  datagram dat;
} NL_OfferElement;
\end{lstlisting}

The following is the implementation of $networkLayerHost()$ with all the important parts.

\begin{lstlisting}
  ConcurrentFifoQueue receivingQueue = CFQ_Init(); //This is concurrent because it is used for communication with the transport layer. The queue is also used for consistence and expandability.
  ConcurrentFifoQueue sendingQueue = CFQ_Init();
  ConcurrentFifoQueue *offer;
  FifoQueue sendingBuffQueue = InitializeFQ();
  FifoQueue receivingBuffQueue = InitializeFQ();
  FifoQueueEntry e;
  TL_OfferElement *o;
  NL_OfferElement *O; //Using a pointer to create a new one every time.
  datagram d;
  ...
  switch(event.type) {
    ...
    case data_for_network_layer:
      d = *((datagram*) (event.msg));
      ...
      switch(d.type) {
        case DATAGRAM:
          o = malloc(sizeof(TL_OfferElement));     //assign little o as TL_OfferElement
          o->otherHostAddress = d.src;             //assign address
          o->seg = d.payload;                      //assign payload

      }
      ...
    case NL_SendingQueueOffer:    //NL_OfferSendingQueue:
      ...
      while(EmptyFQ(offer->queue) == 0) {         //while not empty
        e = DequeueFQ(offer->queue);              //pop an element
        o = ((TL_OfferElement*) ValueOfFQE(e));   //assign it to TL_OfferElement

        d.src = thisNetworkAddress;               //resolve source address
        d.dest = o->otherHostAddress;             //resolve destination address

        d.payload = o->seg;                       //get the segment from TL_OfferElement as our payload for the datagram.



        O = malloc(sizeof(NL_OfferElement));      //assign big O as NL_OfferElement
        O->otherHostNeighbourid = NL_TableLookup(d.dest); //lookup the datagram destination and assign it to otherHostNeighbourid
        O->dat = d;                               //store out datagram in NL_OfferElement
        EnqueueFQ(NewFQE((void *)O), sendingBuffQueue); //send NL_OfferElement to the assembly line
      }
  }
  ...

  TL_OfferReceivingQueue(&receivingQueue);        //NL sends the element in the queue to TL

  ...

  LL_OfferSendingQueue(&sendingQueue);            //NL sends
\end{lstlisting}


$TL_OfferReceivingQueue$ is implemented in the following way:

\begin{lstlisting}
void TL_OfferReceivingQueue(ConcurrentFifoQueue *offer) {
  Signal(TL_ReceivingQueueOffer, (void*) offer);
}
\end{lstlisting}









The following is the implementation of $networkLayerRouter$


\begin{lstlisting}
void networkLayerRouter() {
  //Since this network layer isn't 'fake', it has no condition to stop and relies on the above layer to handle this.
  long int events_we_handle = network_layer_allowed_to_send | data_for_network_layer;
  event_t event;

  boolean allowedToSendToLL = false;

  FifoQueue receivedQueue = InitializeFQ();
  ConcurrentFifoQueue routersendingQueue = CFQ_Init();

  NL_OfferElement *O;

  datagram d;

  while(true) {
    Wait(&event, events_we_handle);

    switch(event.type) {
      case network_layer_allowed_to_send:
        logLine(trace, "NL: Allowed to send by LL.\n");
        allowedToSendToLL = true; //There might not be an element to send right now. Remember that we can send without getting stuck here.
        break;
      case data_for_network_layer:
        logLine(succes, "NL: Received datagram from LL.\n");

        //We're a host. We don't route packets, we receive them.

        d = *((datagram*) (event.msg));

        if(d.dest != thisNetworkAddress) {
          logLine(succes, "NL: Packet was not addressed for this Router. Forwarding.\n");

          O = malloc(sizeof(NL_OfferElement));
          O->otherHostNeighbourid = NL_TableLookup(d.dest);
          O->dat = d;

          logLine(trace, "NL: networkAddresss=%d, neighbourid=%d\n", d.dest, O->otherHostNeighbourid);

          EnqueueFQ(NewFQE((void *)O), receivedQueue);

          break; //Done.
        }

        logLine(trace, "NL: Datagram type (enum): %d.\n", d.type);

        break;
    }

    //logLine(succes, "NL: Trylock of sendingQueue and emptyness of receivedQueue: %d, %d\n", Trylock(routersendingQueue.lock), EmptyFQ(receivedQueue));

    //If the lock is free, then put the received elements into the queue for the LL.
    //if(Trylock(sendingQueue.lock) == 0 && EmptyFQ(receivedQueue) == 0) {
    if(routersendingQueue.used == false && EmptyFQ(receivedQueue) == 0) {
      logLine(trace, "NL: Transfering between queues\n");
      //Lock(sendingQueue.lock); //Nothing else uses it, but for good measure since it's easy here.

      //Transfer from one queue to the other.
      while(EmptyFQ(receivedQueue) == 0) {
        EnqueueFQ(DequeueFQ(receivedQueue), routersendingQueue.queue);
      }

      //Unlock(sendingQueue.lock);
    }

    //If we are allowed to send, then do so.
    // If the signal was sent in this loop iteration: same as if this was in the case directly
    // otherwise: we received something to send after getting clearance and would have been stuck if this was directly in the case.
    if(allowedToSendToLL && EmptyFQ(routersendingQueue.queue) == 0 && routersendingQueue.used == false){//EmptyFQ(receivedQueue) == 0) {
      //e = DequeueFQ(sendingQueue); //Extract from queue

      //Signal(network_layer_ready, ValueOfFQE(e)); //Just pass it directly.

      logLine(trace, "NL: Offering queue to LL\n");

      if(routersendingQueue.used == true) {
      //if(Trylock(routersendingQueue.lock) != 0) {
        logLine(succes, "NL: ERROR: Unable to lock sendingQueue's lock!\n");
      }

      LL_OfferSendingQueue(&routersendingQueue);
      allowedToSendToLL = false;
    }
  }
}
\end{lstlisting}



our implmenetation of the transportlayer is as follows:

\begin{lstlisting}
\end{lstlisting}

the goal is to make the network layer and transport layer communicate with each other, this is done by TODO:


to achieve this/to make this possible a routing table has been implemented with the goal of routing hosts across the network.

TODO: put routing table implementation here

We've implemented a FIFO queue, the idea is to have two queue one for the reciving end and one for the sending end.
We've chosen to make the receivingQueue concurrent because it is shared between TL and the NL.
The concurrency is provided via a simple lock.

\begin{lstlisting}
ConcurrentFifoQueue receivingQueue = CFQ_Init(); //This is concurrent because it is used for communication with the transport layer. The queue is also used for consistence and expandability.
FifoQueue sendingQueue = InitializeFQ(); //Doesn't need to be concurrent because elements are given with signals.
\end{lstlisting}

\\




The NL routing table is implemented the following way.
Here we've defined a static variable, in the real world the $NL_ROUTING_TABLE_SIZE$ should be incremented and decremented dynamically.
\begin{lstlisting}
//Routing table. There can be more elements in this table than there are neighbours and multiple entries can point to the same neighbour.
#define NL_ROUTING_TABLE_SIZE 4
typedef struct {
  networkAddress addresses[NL_ROUTING_TABLE_SIZE];
  neighbourid    neighbourids[NL_ROUTING_TABLE_SIZE];
} NL_RoutingTable;
\end{lstlisting}

\break


The NL offer Element
\begin{lstlisting}
typedef struct {
  neighbourid otherHostNeighbourid;
  datagram dat;
} NL_OfferElement;
\end{lstlisting}

\break

\begin{lstlisting}
typedef struct {
  neighbourid neighbour;
  unsigned int bufferSlotsAvailable;
} NL_RequestFromLL;

\end{lstlisting}



Under the $send_frame(...)$ function we've updated our neighbour addressing to recieve an address instead of a static value.
\begin{lstlisting}
neighbours[recipient].no_nak = false;        /* one nak per frame, please */
\end{lstlisting}














we initialize our networklayer in the following manner.
Each host/station is assigned an address

\begin{lstlisting}
void initialize_networkLayer(int stationID) {
   switch(stationID) {
     case 1: //Host A
      thisNetworkAddress = 111;
       ROUTINGTABLEADD(0, 212, 0);
       ROUTINGTABLEADD(1, -1, -1);
       ROUTINGTABLEADD(2, -1, -1);
       ROUTINGTABLEADD(3, -1, -1);
       break;
     case 2: //Host B
       thisNetworkAddress = 212;
      ROUTINGTABLEADD(0, 111, 0);
       ROUTINGTABLEADD(1, -1, -1);
       ROUTINGTABLEADD(2, -1, -1);
       ROUTINGTABLEADD(3, -1, -1);
       break;
     case 3: //Router 1

      thisNetworkAddress = 313;
      ROUTINGTABLEADD(0, 111, 0);
      ROUTINGTABLEADD(1, 212, 1);
      ROUTINGTABLEADD(2, -1, -1);
      ROUTINGTABLEADD(3, -1, -1);
      break;
     case 4: //Router 2

       //break;
@@ -46,6 +50,22 @@ void initialize_networkLayer(int stationID) {
   }
 }
\end{lstlisting}



\hfill \break
