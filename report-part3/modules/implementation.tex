Â½\section{Implementation}

\subsection{Link Layer}
\subsubsection{Neighbours}
The neighbour switching is handled in the selective repeat using a variable called $currentNeighbour$. This variable is set at as early as possible when handling each of the three types of signals handled by selective repeat.\\
The snippets here are trimmed extensively. To get a clear overview, please read the event handling cases in the source file rdt.c. Comments have also been removed.\\
\\~
network\_layer\_ready:\\
The id of the neighbour the packet is intended to be sent to is stored in the msg variable of the event.\\
The fake network layer written for testing gives this value when signaling:
\begin{lstlisting}
Signal(network\_layer\_ready, i);
\end{lstlisting}
And the selective repeat function reads this value when handling the event:
\begin{lstlisting}
currentNeighbour = event.msg;
\end{lstlisting}

frame\_arrival:\\
The id of the neighbour that sent the packet is returned by the function $from\_physical\_layer$.
\begin{lstlisting}
currentNeighbour = from\_physical\_layer(&r);
\end{lstlisting}

timeout:\\
The timer message contains the id of the neighbour it enables.
\begin{lstlisting}
currentNeighbour = ((packetTimerMessage*)event.msg)->neighbour;
\end{lstlisting}

\subsection{Network Layer}
\subsubsection{Datagram}
Datagrams is used for handling messages from/to the transport layer.
The implementation of the datagram and payload is as follows.
\begin{lstlisting}
typedef struct  {
  //First 32bit word
  unsigned char type;
  unsigned short payloadsize;

  //Two next 32-bit words
  networkAddress src;
  networkAddress dest;

  TL_Segment segment;
} datagram;
\end{lstlisting}
The networkAddress is defined as a 32-bit address similarly to IPv4.

\subsubsection{Network Layer Implementation}

The following is the implementation of \texttt{NL\_RoutingTable}, the routing table is used to look up hosts and routers in the network.
Here we've defined a static variable, in the real world the \texttt{NL\_ROUTING\_TABLE\_SIZE} should be incremented and decremented dynamically.
There can be more elements in Routing table than there are neighbours and multiple entries can point to the same neighbour.
\begin{lstlisting}
#define NL_ROUTING_TABLE_SIZE 4
typedef struct {
  networkAddress addresses[NL_ROUTING_TABLE_SIZE];
  neighbourid    neighbourids[NL_ROUTING_TABLE_SIZE];
} NL_RoutingTable;
\end{lstlisting}

The following is the implementation of the signal handling in \texttt{networkLayerRouter()} with unessential parts ommited. The implementation showcases the essential components of receiving from LL and the packet forwarding.
\begin{lstlisting}
void networkLayerRouter() {
  while(true) {
    Wait(&event, events_we_handle); //block for a new event
    switch(event.type) { //handle events
      case network_layer_allowed_to_send:
        allowedToSendToLL = true;
        break;
      case data_for_network_layer: //received from LL
        d = *((datagram*) (event.msg));
        if(d.dest != thisNetworkAddress) { //forward if not addressed to this router
          O = malloc(sizeof(NL_OfferElement));
          O->otherHostNeighbourid = NL_TableLookup(d.dest); //Lookup the destination
          O->dat = d;
          EnqueueFQ(NewFQE((void *)O), receivedQueue);
          break;
        }
        break;
    }
  }
}
\end{lstlisting}

\subsection{Transport Layer}

\begin{lstlisting}
typedef struct {
  unsigned int valid:1; //Checked on init.
  unsigned int pending:1;
  unsigned int disconnected:1; //This is because you might still want to read messages from the connection after it was disconnected. Also allows for the application to look directly at this.
  networkAddress remoteAddress; //Address of the other machine
  transPORT remotePort; //Port of the other application
  unsigned int outboundSeqMsg; //seqMsg of next message to send.
  unsigned int inboundSeqMsg;  //seqMsg of next message to receive.
  TLMessageBufferLL *msgListHead; //Head of the linked list of messages. If this one has fragmentsRemaining == 0, then its msg can be received by the application.
  TLMessageBufferLL *msgListTail; //Tail of the linked list of messages
} TLConnection;
\end{lstlisting}

\begin{lstlisting}
typedef struct {
  unsigned int valid:1; //Checked upon init. The TL sets this as an indicator for the AL.
  unsigned int listening:2; //This is used to keep track of listening status and when to break out of waiting in the listening function.
  unsigned int listenConnection; //When listening, this value will be set to the id of the connection listened to.
  transPORT port; //The port of the socket. The application can check this value to see which port is has been given if it chose any port.
  TLConnection connections[MAX_CONNECTIONS]; //Connections
} TLSocket;
\end{lstlisting}

\subsubsection{TL\_SocketRequest}
Below is the implementation of $TL\_SocketRequest$ this signal used for creating a sockets.
it does this by evaluating the requested socket and it's availability if available returns the socket otherwise an invalid error socket.
\begin{lstlisting}
case TL_SocketRequest:
  req = (TLSockReq*) event.msg;
  if(req->port == SOCKET_ANY) {
    logLine(info, "Request to any port.\n");
    for(int i = 0; i < NUM_MAX_SOCKETS; i++) {
      if(sockets[i] == NULL) {
        req->port = i;
        logLine(info, "Decided on port number %d\n", req->port);
        break;
      }
    }
   if(req->port == SOCKET_ANY) { //Copy-paste
      logLine(info, "Unable to deliver requested socket.\n");
      socket = malloc(sizeof(TLSocket*));
      (*socket) = malloc(sizeof(TLSocket));
      (*socket)->valid = 0;
      req->sock = (*socket);
      socket = NULL; //For good measure.
      break;
    }
  } else {
    if(sockets[req->port] != NULL || req->port >= NUM_MAX_SOCKETS) {
      logLine(info, "Unable to deliver requested socket.\n");
      socket = malloc(sizeof(TLSocket*));
      (*socket) = malloc(sizeof(TLSocket));
      (*socket)->valid = 0;
      req->sock = (*socket);
      socket = NULL; //For good measure.
      break;
    }
  }
  logLine(trace, "Allocating socket.\n");
  sockets[req->port] = malloc(sizeof(TLSocket));
  logLine(trace, "Setting socket port and validity.\n");
  (sockets[req->port])->port = req->port;
  (sockets[req->port])->valid = 1; //The port is valid.
  (sockets[req->port])->listening = 0; //The port is valid.
  (sockets[req->port])->listenConnection = CONNECTION_PENDING; //The port is valid.
  logLine(trace, "Setting conection default values.\n");
  for(int i = 0; i < MAX_CONNECTIONS; i++) {
    logLine(trace, "Setting for %d\n", i);
    sockets[req->port]->connections[i].valid = 0;
    sockets[req->port]->connections[i].pending = 0;
    sockets[req->port]->connections[i].disconnected = 0;
    sockets[req->port]->connections[i].remoteAddress = 0;
    sockets[req->port]->connections[i].remotePort = 0;
    sockets[req->port]->connections[i].outboundSeqMsg = 0;
    sockets[req->port]->connections[i].inboundSeqMsg = 0;
    sockets[req->port]->connections[i].msgListHead = NULL;
    sockets[req->port]->connections[i].msgListTail = NULL;
    logLine(trace, "Done setting for %d\n", i);
  }
  logLine(trace, "Setting request socket pointer to resulting socket.");
  req->sock = sockets[req->port];
break;
\end{lstlisting}

\subsubsection{AL\_Connect}
The following is the implementation of $connect$ in AL.
As function arguments, we require a socket and reciever address along with port.
We create the $ALConnReq$ header and send it to the TL for processing,
this also means that the TL is responsible for error handling for this function.
We use $AL\_Connect$ for sending the signal and an implementation of the signal processing is given down below.

\subsubsection{AL\_Disconnect}

The $disconnect$ function in AL is implemented the following way, the recieved parameters are the socket and the connection id that needs to be terminated.
first we make sure that the connection hasn't already terminated and that the socket is still a valid socket.
We then set the connection to not valid and create a struct $disconnectReq$ which holds our socket and connection id, this is then sent to the TL.
the TL layer then processes the request.
In TL our ALDisconnectReq is and derived from the AL via $event.msg$
To disconnect the connection we send to the connected reciever that the connection is no longer valid, to archieve this
we utilize again our $TL\_OfferElement$ to send a control segment to the NL, which passes it on.

\subsubsection{AL\_Send}
The $send$ function in AL takes the message and encapsulates it into a message header then sends it down the chain to TL.
Below is the implementation of the $send$ function.
\begin{lstlisting}
int send(TLSocket *socket, unsigned int connectionid, char *data, unsigned int length) {
  ALMessageSend *MS = (ALMessageSend*) malloc(sizeof(ALMessageSend));
  MS->socketToUse = socket;
  MS->connectionid = connectionid;
  MS->message = data;
  MS->length = length;

  Signal(AL_Send, MS);
  return 0;
}
\end{lstlisting}

$AL\_Send$ event in TL is implemented in the following way, first we retrieve the signal from AL and then we split the message as fragments, this is done because a payload is defined as 8 bytes and thus we have to split the msg 8 bytes at a time. Each fragment is then send as a segment, down to the NL.




\subsubsection{AL\_Receive}
Below is the implementation of $AL\_Receive$ with the most critical parts.
First the signal is retrieved from the AL and then checked for validity and that we've received the whole message.
Afterwards, we send it to the AL.
\begin{lstlisting}
case AL_Receive:
  ALMessageSend *MR = (ALMessageSend*) event.msg;

  TLSocket *socket = MR->socketToUse;

  logLine(debug, "%d %p \n", socket->connections[MR->connectionid].valid, socket->connections[MR->connectionid].msgListHead);
  if(socket->connections[MR->connectionid].msgListHead != NULL){
    logLine(debug, "sequence ids: %d, %d, %d\n", socket->connections[MR->connectionid].inboundSeqMsg, (socket->connections[MR->connectionid].msgListHead)->seqMsg, (socket->connections[MR->connectionid].msgListHead)->fragmentsRemaining);
  }

  if(socket->valid //Socket is valid
    && socket->connections[MR->connectionid].valid //Connection is valid
    && socket->connections[MR->connectionid].msgListHead != NULL //There is a message
    && socket->connections[MR->connectionid].inboundSeqMsg == (socket->connections[MR->connectionid].msgListHead)->seqMsg //The message is the one we want
    && (socket->connections[MR->connectionid].msgListHead)->fragmentsRemaining == 0 //The whole message has arrived.
    ) {
    TLMessageBufferLL *tmp = socket->connections[MR->connectionid].msgListHead;
    MR->length = tmp->msgLen;
    MR->message = tmp->msg; //update the message pointer to AL.

    socket->connections[MR->connectionid].msgListHead = tmp->next;
    free(tmp);
    socket->connections[MR->connectionid].inboundSeqMsg++;
  }

  MR->aux = 0;
break;
\end{lstlisting}


\subsubsection{AL\_Listen}
Below is the implementation of $listen$ in AL.
Which blocks and listens for incomming packets on the socket.
\begin{lstlisting}
int listen(TLSocket *socket) {
  if (socket->valid == 1) {
      socket->listening |= 1;
      while(socket->listenConnection == CONNECTION_PENDING) {
        sleep(1);
      }
      socket->listening = 0;
      return socket->listenConnection;
  } else {
      return -1;
  }
}
\end{lstlisting}



\hfill \break
