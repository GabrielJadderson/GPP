\section{Implementation}

\subsubsection{Neighbours}
The neighbour switching is handled in the selective repeat using a variable called $currentNeighbour$. This variable is set at as early as possible when handling each of the three types of signals handled by selective repeat.\\
The snippets here are trimmed extensively. To get a clear overview, please read the event handling cases in the source file rdt.c. Comments have also been removed.\\
\\~
network\_layer\_ready:\\
The id of the neighbour the packet is intended to be sent to is stored in the msg variable of the event.\\
The fake network layer written for testing gives this value when signaling:
\begin{lstlisting}
Signal(network\_layer\_ready, i);
\end{lstlisting}
And the selective repeat function reads this value when handling the event:
\begin{lstlisting}
currentNeighbour = event.msg;
\end{lstlisting}

frame\_arrival:\\
The id of the neighbour that sent the packet is returned by the function $from\_physical\_layer$.
\begin{lstlisting}
currentNeighbour = from\_physical\_layer(&r);
\end{lstlisting}

timeout:\\
The timer message contains the id of the neighbour it enables.
\begin{lstlisting}
currentNeighbour = ((packetTimerMessage*)event.msg)->neighbour;
\end{lstlisting}
\subsubsection{Signals}
The following is a description of what the three events in our code do:
\begin{description}[leftmargin=1em, style=nextline]
\item [\texttt{network\_layer\_allowed\_to\_send}] Signals the network layer that it can send a piece of data.
Here the network layer should make sure the \texttt{from\_network\_layer\_queue}
contains at least one element, after which it can signal \texttt{network\_layer\_ready},
which means that the network layer has prepared at least one element in the queue.

\item [\texttt{network\_layer\_ready}] This signal signals to the link layer that the network layer has prepared an element to be sent in the
 \texttt{from\_network\_layer\_queue} queue and that it should be sent now.

\item [\texttt{data\_for\_network\_layer}]
This signal signals to the network layer that the
\texttt{for\_network\_layer\_queue} contains a data element for it to take care of. (a data element has been received)
\end{description}

\subsubsection{Datagram}
Datagrams is used for handling messages from/to the transport layer.
The implementation of the datagram and payload is as follows.
\begin{lstlisting}
typedef struct  {
  //First 32bit word
  unsigned char type;
  unsigned short payloadsize;

  //Two next 32-bit words
  networkAddress src;
  networkAddress dest;

  TL_Segment segment;
} datagram;
\end{lstlisting}
The networkAddress is defined as a 32-bit address similarly to IPv4.

\subsubsection{Network Layer}

The following is the implementation of \texttt{NL\_RoutingTable}, the routing table is used to look up hosts and routers in the network.
Here we've defined a static variable, in the real world the \texttt{NL\_ROUTING\_TABLE\_SIZE} should be incremented and decremented dynamically.
There can be more elements in Routing table than there are neighbours and multiple entries can point to the same neighbour.
\begin{lstlisting}
#define NL_ROUTING_TABLE_SIZE 4
typedef struct {
  networkAddress addresses[NL_ROUTING_TABLE_SIZE];
  neighbourid    neighbourids[NL_ROUTING_TABLE_SIZE];
} NL_RoutingTable;
\end{lstlisting}

Similarly \texttt{NL\_OfferElement} is used in the communication between LL and NL.
\begin{lstlisting}
typedef struct {
  neighbourid otherHostNeighbourid;
  datagram dat;
} NL_OfferElement;
\end{lstlisting}

The following is the implementation of the signal handling in \texttt{networkLayerRouter()} with unimportant parts ommited.
\begin{lstlisting}
void networkLayerRouter() {
  while(true) {
    Wait(&event, events_we_handle); //block for a new event
    switch(event.type) { //handle events
      case network_layer_allowed_to_send:
        allowedToSendToLL = true;
        break;
      case data_for_network_layer: //received from LL
        d = *((datagram*) (event.msg));
        if(d.dest != thisNetworkAddress) { //forward if not addressed to this router
          O = malloc(sizeof(NL_OfferElement));
          O->otherHostNeighbourid = NL_TableLookup(d.dest); //Lookup the destination
          O->dat = d;
          EnqueueFQ(NewFQE((void *)O), receivedQueue);
          break;
        }
        break;
    }
  }
}
\end{lstlisting}



\subsubsection{Transport Layer}
Our implementation of the TL with only the most important parts is as follows.
this implementation focuses on the handling of signals, under the hood we use a fifo-queue and the $TL_OfferElement$.
Our TL is run in a seperate thread, therefore, we block until we get a signal at then we process the signal.
\begin{lstlisting}
void fake_transportLayer() {
  while(true) {
    Wait(&event, events_we_handle); //block until a valid signal is recieved.
    switch(event.type) {
      case TL_ReceivingQueueOffer: //Received the TL_ReceivingQueueOffer signal.
        offer = (ConcurrentFifoQueue*) event.msg;
        while(EmptyFQ(offer->queue) == 0) { //Handle incoming messages
          e = DequeueFQ(offer->queue);
          o = *((TL_OfferElement*) (e->val));
        }
        numReceivedPackets++;
        break;
    }
    ... //more signals to be implemented.
  }
}
\end{lstlisting}

In part 3 we've extended $events.h$ and included events from $transportLayer.h$ and $appplicationLayer.h$
below is a list of the newly added events.
\begin{itemize}
\item \texttt{TL\_SocketRequest}: Used to assign a new unique socket, TL handles this.

\item \texttt{AL\_Connect}: Called from AL to TL.
We check if the connections array isn't fully occupied and try to open a connection and assign a connection id.

\item \texttt{AL\_Disconnect}: Called from AL to TL. First we make sure that the connection is active, then we de-register the connection in our $connections$ array.
a signal is sent to the recieving host that the connection has been terminated.

\item \texttt{AL\_Send}: Called from AL to TL.

\item \texttt{AL\_Receive}: Called from AL to TL.

\end{itemize}

\subsubsection{TL\_SocketRequest}
Below is the implementation of $TL\_SocketRequest$ this signal used for creating a sockets.
it does this by evaluating the requested socket and it's availability if available returns the socket otherwise an invalid error socket.
\begin{lstlisting}
case TL_SocketRequest:
  req = (TLSockReq*) event.msg;
  if(req->port == SOCKET_ANY) {
    logLine(info, "Request to any port.\n");
    for(int i = 0; i < NUM_MAX_SOCKETS; i++) {
      if(sockets[i] == NULL) {
        req->port = i;
        logLine(info, "Decided on port number %d\n", req->port);
        break;
      }
    }
   if(req->port == SOCKET_ANY) { //Copy-paste
      logLine(info, "Unable to deliver requested socket.\n");
      socket = malloc(sizeof(TLSocket*));
      (*socket) = malloc(sizeof(TLSocket));
      (*socket)->valid = 0;
      req->sock = (*socket);
      socket = NULL; //For good measure.
      break;
    }
  } else {
    if(sockets[req->port] != NULL || req->port >= NUM_MAX_SOCKETS) {
      logLine(info, "Unable to deliver requested socket.\n");
      socket = malloc(sizeof(TLSocket*));
      (*socket) = malloc(sizeof(TLSocket));
      (*socket)->valid = 0;
      req->sock = (*socket);
      socket = NULL; //For good measure.
      break;
    }
  }
  logLine(trace, "Allocating socket.\n");
  sockets[req->port] = malloc(sizeof(TLSocket));
  logLine(trace, "Setting socket port and validity.\n");
  (sockets[req->port])->port = req->port;
  (sockets[req->port])->valid = 1; //The port is valid.
  (sockets[req->port])->listening = 0; //The port is valid.
  (sockets[req->port])->listenConnection = CONNECTION_PENDING; //The port is valid.
  logLine(trace, "Setting conection default values.\n");
  for(int i = 0; i < MAX_CONNECTIONS; i++) {
    logLine(trace, "Setting for %d\n", i);
    sockets[req->port]->connections[i].valid = 0;
    sockets[req->port]->connections[i].pending = 0;
    sockets[req->port]->connections[i].disconnected = 0;
    sockets[req->port]->connections[i].remoteAddress = 0;
    sockets[req->port]->connections[i].remotePort = 0;
    sockets[req->port]->connections[i].outboundSeqMsg = 0;
    sockets[req->port]->connections[i].inboundSeqMsg = 0;
    sockets[req->port]->connections[i].msgListHead = NULL;
    sockets[req->port]->connections[i].msgListTail = NULL;
    logLine(trace, "Done setting for %d\n", i);
  }
  logLine(trace, "Setting request socket pointer to resulting socket.");
  req->sock = sockets[req->port];
break;
\end{lstlisting}

\subsubsection{AL\_Connect}
The following is the implementation of $connect$ in AL.
As function arguments, we require a socket and reciever address along with port.
We create the $ALConnReq$ header and send it to the TL for processing,
this also means that the TL is responsible for error handling for this function.
We use $AL\_Connect$ for sending the signal and an implementation of the signal processing is given down below.
\begin{lstlisting}
int connect(TLSocket *socket, networkAddress addr, transPORT port) {
  if(!socket->valid) { return -1; }
  ALConnReq* connReq = malloc(sizeof(ALConnReq));
  connReq->port = port;
  connReq->sock = socket;
  connReq->netAddress = addr;
  connReq->connectionid = CONNECTION_PENDING;
  Signal(AL_Connect, connReq);
  //wait for the connection to be established.
  for(int i = 0; i < 3 && (connReq->connectionid == CONNECTION_PENDING || socket->connections[connReq->connectionid].pending) == 1; i++) { sleep(1); }
\end{lstlisting}

The following is the connection request header.
\begin{lstlisting}
typedef struct {
  transPORT port; //Port that is receiving.
  networkAddress netAddress; //the address to the reciever.
  TLSocket *sock; //Socket to establish a connection with.
  unsigned int connectionid; //The id of the connection established by TL.
} ALConnReq;
\end{lstlisting}

Below is the implementation of the signal $AL\_Connect$.
First we retrieve the header from AL: ALConnReq, afterwards, we check and make sure that
there is an available free slot for our connection and update the connection variables.
We then construct a $TL\_OfferElement$ with the required information and send it to the NL.
\begin{lstlisting}
case AL_Connect:
  ALConnReq *connReq = (ALConnReq*) event.msg;
  boolean gotAssigned = false;
  for (int i = 0; i < MAX_CONNECTIONS && gotAssigned == false; i++) {
    if (connReq->sock->connections[i].valid == 0 && connReq->sock->connections[i].pending == 0 && connReq->sock->connections[i].disconnected == 0) {
        connReq->sock->connections[i].pending = 1; //assign that this connection is pending for a response.
        connReq->sock->connections[i].disconnected = 0; //assign that this connection is pending for a response.
        connReq->sock->connections[i].remoteAddress = connReq->netAddress;
        //Reset these values.
        connReq->sock->connections[conid].outboundSeqMsg = 0;
        connReq->sock->connections[conid].inboundSeqMsg = 0;
        connReq->sock->connections[conid].msgListHead = NULL;
        connReq->sock->connections[conid].msgListTail = NULL;

        connReq->connectionid = i; //update the connReq to return in AL
        gotAssigned = true; //indicate that the connection was assigned sucessfully.
        conid = i;
        break;
    }
  }
  if (gotAssigned == false) {
    connReq->connectionid = CONNECTION_FAILURE;
    break;
  }
  O = (TL_OfferElement*) malloc(sizeof(TL_OfferElement));
  O->otherHostAddress = connReq->netAddress;
  O->segment.is_first = 1;
  O->segment.is_control = 1;
  O->segment.seqMsg = 0;
  O->segment.seqPayload = 0;
  O->segment.senderport = connReq->sock->port;
  O->segment.receiverport = connReq->port; //This one should correspond to the open connection
  O->segment.aux = 0;
  memset(&(O->segment.msg.data), 0, 8);
  EnqueueFQ( NewFQE( (void *) O ), sendingBuffQueue);
break;
\end{lstlisting}


\subsubsection{AL\_Disconnect}

Below is the implementation of the $disconnect$ function, recieved parameters are the socket and the connection id that needs to be terminated.
first we make sure that the connection hasn't already terminated and that the socket is still a valid socket.
We then set the connection to not valid and create a struct $disconnectReq$ which holds our socket and connection id, this is then sent to the TL.
the TL layer then processes the request.
\begin{lstlisting}
int disconnect(TLSocket *socket, unsigned int connectionid) {
  if (!socket || connectionid < 0) {
      return -1;
  }
  if (socket->connections[connectionid].valid != 1) {
      return -1;
  }
  socket->connections[connectionid].valid = 0;
  ALDisconnectReq* disconnectReq = malloc(sizeof(ALDisconnectReq));
  disconnectReq->sock = socket;
  disconnectReq->connectionid = connectionid;
  Signal(AL_Disconnect, disconnectReq); //Send to TL
  return 0;
}
\end{lstlisting}


Below is the implementation of the signal $AL\_Disconnect$.
First our ALDisconnectReq is created and derived from the AL via $event.msg$
To disconnect the connection we send to the connected reciever that the connection is no longer valid, to archieve this
we utilize again our $TL\_OfferElement$ to send a control segment to the NL, which passes it on.
\begin{lstlisting}
case AL_Disconnect:
  ALDisconnectReq* disconnectReq = (ALDisconnectReq*) event.msg;
  //If the other end has disconnected, just clean up our own side.
  if(disconnectReq->sock->connections[disconnectReq->connectionid].disconnected == 0) {
    O = (TL_OfferElement*) malloc(sizeof(TL_OfferElement));
    O->otherHostAddress = disconnectReq->sock->connections[disconnectReq->connectionid].remoteAddress;
    O->segment.is_first = 1;
    O->segment.is_control = 1;
    O->segment.seqMsg = 0;
    O->segment.seqPayload = 0;
    O->segment.senderport = disconnectReq->sock->port;
    O->segment.receiverport = disconnectReq->sock->connections[disconnectReq->connectionid].remotePort; //This one should correspond to the open connection
    O->segment.aux = 1;
    memset(&(O->segment.msg.data), 0, 8);
    EnqueueFQ( NewFQE( (void *) O ), sendingBuffQueue);
  }
  //The disconnecting side assumes that all the important messages have been read.
  disconnectReq->sock->connections[disconnectReq->connectionid].valid = 0;
  disconnectReq->sock->connections[disconnectReq->connectionid].disconnected = 0;
  disconnectReq->sock->connections[disconnectReq->connectionid].pending = 0;
  disconnectReq->sock->connections[disconnectReq->connectionid].remoteAddress = 0;
  disconnectReq->sock->connections[disconnectReq->connectionid].remotePort = 0;
  disconnectReq->sock->connections[disconnectReq->connectionid].outboundSeqMsg = 0;
  disconnectReq->sock->connections[disconnectReq->connectionid].inboundSeqMsg = 0;
  disconnectReq->sock->connections[disconnectReq->connectionid].msgListHead = NULL;
  disconnectReq->sock->connections[disconnectReq->connectionid].msgListTail = NULL;
break;
\end{lstlisting}

\subsubsection{AL\_Send}
The $send$ function takes the message and encapsulates it into a message header then sends it down the chain to TL.
Below is the implementation of the $send$ function in AL.
\begin{lstlisting}
int send(TLSocket *socket, unsigned int connectionid, char *data, unsigned int length) {
  ALMessageSend *MS = (ALMessageSend*) malloc(sizeof(ALMessageSend));
  MS->socketToUse = socket;
  MS->connectionid = connectionid;
  MS->message = data;
  MS->length = length;

  Signal(AL_Send, MS);
  return 0;
}
\end{lstlisting}

Below is the implementation of $AL\_Send$ with the most critical parts.
Frist we retrieve the signal from AL and then we split the message as fragments,
each fragment is then send as a segment, down to the NL.
\begin{lstlisting}
case AL_Send:
  ALMessageSend *MS = (ALMessageSend*) event.msg;
  TLSocket *socketToUse = MS->socketToUse;
  unsigned int connectionToUse = MS->connectionid;
  char* msgToSplit = MS->message;
  unsigned int msglen = MS->length;
  networkAddress targetAddress = socketToUse->connections[connectionToUse].remoteAddress;
  transPORT targetPort = socketToUse->connections[connectionToUse].remotePort;
  unsigned int seqMsg = socketToUse->connections[connectionToUse].outboundSeqMsg;

  int cpa = MAX_PAYLOAD;
  int numFragments = msglen / MAX_PAYLOAD;
  if(numFragments*MAX_PAYLOAD < msglen) {numFragments++;};
  if(msglen < cpa) {cpa = msglen;}

  //First fragment. Set to be the fourth message (3).
  O = (TL_OfferElement*) malloc(sizeof(TL_OfferElement));
  O->otherHostAddress = targetAddress;
  O->segment.is_first = 1;
  O->segment.is_control = 0;
  O->segment.seqMsg = seqMsg;
  O->segment.seqPayload = numFragments-1;
  O->segment.senderport = socketToUse->port;
  O->segment.receiverport = targetPort;
  O->segment.aux = msglen;
  memcpy(&(O->segment.msg.data), msgToSplit, cpa);
  memcpy(&(O->seg.data), msgToSplit, cpa);

  int i = 0;
  while(true) { //split the rest
      EnqueueFQ( NewFQE( (void *) O ), sendingBuffQueue);
      i++; //Important that this comes first.
      if(i >= numFragments) {
        break;
      }

      O = (TL_OfferElement*) malloc(sizeof(TL_OfferElement));
      O->otherHostAddress = targetAddress;
      O->segment.is_first = 0;
      O->segment.is_control = 0;
      O->segment.seqMsg = seqMsg;
      O->segment.seqPayload = i;
      O->segment.senderport = socketToUse->port;
      O->segment.receiverport = targetPort;
      O->segment.aux = 0;

      cpa = MAX_PAYLOAD;

      if((i+1)*MAX_PAYLOAD > msglen) { //check if last fragment
        O->segment.aux = msglen % MAX_PAYLOAD;
        cpa = msglen % MAX_PAYLOAD;
      }
      memcpy(&(O->segment.msg.data), msgToSplit+(i*MAX_PAYLOAD), MAX_PAYLOAD);
      memcpy(&(O->seg.data), msgToSplit+(i*MAX_PAYLOAD), MAX_PAYLOAD);
    }
    socketToUse->connections[connectionToUse].outboundSeqMsg += 1;
break;
\end{lstlisting}

\subsubsection{AL\_Receive}
Below is the implementation of $AL\_Receive$ with the most critical parts.
First the signal is retrieved from the AL and then checked for validity and that we've received the whole message.
Afterwards, we send it to the AL.
\begin{lstlisting}
case AL_Receive:
  ALMessageSend *MR = (ALMessageSend*) event.msg;

  TLSocket *socket = MR->socketToUse;

  logLine(debug, "%d %p \n", socket->connections[MR->connectionid].valid, socket->connections[MR->connectionid].msgListHead);
  if(socket->connections[MR->connectionid].msgListHead != NULL){
    logLine(debug, "sequence ids: %d, %d, %d\n", socket->connections[MR->connectionid].inboundSeqMsg, (socket->connections[MR->connectionid].msgListHead)->seqMsg, (socket->connections[MR->connectionid].msgListHead)->fragmentsRemaining);
  }

  if(socket->valid //Socket is valid
    && socket->connections[MR->connectionid].valid //Connection is valid
    && socket->connections[MR->connectionid].msgListHead != NULL //There is a message
    && socket->connections[MR->connectionid].inboundSeqMsg == (socket->connections[MR->connectionid].msgListHead)->seqMsg //The message is the one we want
    && (socket->connections[MR->connectionid].msgListHead)->fragmentsRemaining == 0 //The whole message has arrived.
    ) {
    TLMessageBufferLL *tmp = socket->connections[MR->connectionid].msgListHead;
    MR->length = tmp->msgLen;
    MR->message = tmp->msg; //update the message pointer to AL.

    socket->connections[MR->connectionid].msgListHead = tmp->next;
    free(tmp);
    socket->connections[MR->connectionid].inboundSeqMsg++;
  }

  MR->aux = 0;
break;
\end{lstlisting}

\subsubsection{AL\_Listen}
Below is the implementation of $listen$ in AL.
Which blocks and listens for incomming packets on the socket.
\begin{lstlisting}
int listen(TLSocket *socket) {
  if (socket->valid == 1) {
      socket->listening |= 1;
      while(socket->listenConnection == CONNECTION_PENDING) {
        sleep(1);
      }
      socket->listening = 0;
      return socket->listenConnection;
  } else {
      return -1;
  }
}
\end{lstlisting}



\hfill \break
